
//func ReWrite2_UMinus(ast *ParseTree) (rv *ParseTree) {
//	if ast == nil {
//		return nil
//	}
//	if ast.Left != nil {
//		ast.Left = ReWrite2_UMinus(ast.Left)
//	}
//	if ast.Right != nil {
//		ast.Right = ReWrite2_UMinus(ast.Right)
//	}
//	if ast.Op == PtU_Minus {
//		ast.Op = PtSub
//		ast.Right = ast.Left
//		st, _ := LookupConst(0, ast.LineNo)
//		ast.Left = &ParseTree{
//			Op:     PtNum,
//			OpName: "PtNum",
//			LineNo: ast.LineNo,
//			Name:   "_0",
//			Value:  0,
//			St:     st,
//		}
//	}
//	return ast
//}

// ------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------

var nc = 0

// The parser calls this method to get each new token. This
// implementation returns operators and NUM.
func (x *exprLex) Lex(yylval *exprSymType) int {
	ct := x.Tokens[x.Pd.curPos]
	fmt.Printf("%s in .Lex - curPos=%d getting token %7d ->%s<->%s<-, at:%s \n%s", MiscLib.ColorYellow, x.Pd.curPos, ct.Tok, ct.SM, ct.TokName, godebug.LF(), MiscLib.ColorReset)
	x.Pd.curPos++
	nc++
	if nc > 15 {
		os.Exit(1)
	}
	if ct.Tok == TokNum {
		// yylval.tree = NewAst(OpNum, nil, nil, ct.LineNo)
		// yylval.tree.SValue = ct.SM
		// yylval.tree.IValue = ct.Value
		yylval.tree = NewAstNUM(ct.SM, ct.Value, ct.LineNo)
	}
	if ct.Tok == TokID {
		// yylval.tree = NewAst(OpID, nil, nil, ct.LineNo)
		// yylval.tree.SValue = ct.SM
		yylval.tree = NewAstID(ct.SM, ct.LineNo)
	}
	x.peek = rune(x.Tokens[x.Pd.curPos].Tok)
	return int(ct.Tok)

	//	for {
	//		c := x.next()
	//		switch c {
	//		case eof:
	//			return eof
	//		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
	//			return x.num(c, yylval)
	//		case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j':
	//			return x.id(c, yylval)
	//		case '+', '-', '*', '/', '(', ')', ';', '=':
	//			return int(c)

	//		// Recognize Unicode multiplication and division
	//		// symbols, returning what the parser expects.
	//		case 'ร':
	//			return '*'
	//		case 'รท':
	//			return '/'

	//		case ' ', '\t', '\r':
	//		case '\n':
	//			line_no++

	//		default:
	//			log.Printf("unrecognized character %q", c)
	//		}
	//	}
}

//// Lex a number.
//func (x *exprLex) num(c rune, yylval *exprSymType) int {
//	add := func(b *bytes.Buffer, c rune) {
//		if _, err := b.WriteRune(c); err != nil {
//			log.Fatalf("WriteRune: %s", err)
//		}
//	}
//	var b bytes.Buffer
//	add(&b, c)
//L:
//	for {
//		c = x.next()
//		switch c {
//		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E':
//			add(&b, c)
//		default:
//			break L
//		}
//	}
//	if c != eof {
//		x.peek = c
//	}
//	yylval.tree = NewAst(OpNum, nil, nil, x.Pd.LineNo)
//	yylval.tree.SValue = b.String()
//	// xyzzy - convert to int for other things
//
//	//	yylval.num = &big.Rat{}
//	//	_, ok := yylval.num.SetString(b.String())
//	//	if !ok {
//	//		log.Printf("bad number %q", b.String())
//	//		return eof
//	//	}
//
//	return NUM
//}
//
//// Lex an ID
//func (x *exprLex) id(c rune, yylval *exprSymType) int {
//	add := func(b *bytes.Buffer, c rune) {
//		if _, err := b.WriteRune(c); err != nil {
//			log.Fatalf("WriteRune: %s", err)
//		}
//	}
//	var b bytes.Buffer
//	add(&b, c)
//	yylval.tree = NewAst(OpID, nil, nil, x.Pd.LineNo)
//	yylval.tree.SValue = b.String()
//	return ID
//}
//
//// Return the next rune for the lexer.
//func (x *exprLex) next() rune {
//	if x.peek != eof {
//		r := x.peek
//		x.peek = eof
//		return r
//	}
//	if len(x.line) == 0 {
//		return eof
//	}
//	c, size := utf8.DecodeRune(x.line)
//	x.line = x.line[size:]
//	if c == utf8.RuneError && size == 1 {
//		log.Print("invalid utf8")
//		return x.next()
//	}
//	return c
//}

// The parser calls this method on a parse error.
func (x *exprLex) Error(s string) {
	log.Printf("parse error: %s", s)
}
//var valTab = make(map[int]string)
//
//func gen_AssignConstants(ast *ParseTree, kk *int) {
//	if ast == nil {
//		return
//	}
//	if ast.Op == PtNUM {
//		s, ok := valTab[ast.Value]
//		if ok {
//			ast.Name = s
//		} else {
//			ast.Name = fmt.Sprintf("c_%d", *kk)
//			valTab[ast.Value] = ast.Name
//			(*kk)++
//		}
//	}
//	if ast.Left != nil {
//		gen_AssignConstants(ast.Left, kk)
//	}
//	if ast.Right != nil {
//		gen_AssignConstants(ast.Right, kk)
//	}
//}
//
//func DumpTree(ast *ParseTree, lev int) (rv string) {
//	rv = "--not implemented yet--"
//	return
//}
//
//func gen_Inorder(ast *ParseTree, kk *int) {
//	if ast.Left != nil {
//	}
//	if ast.Right != nil {
//	}
//	if ast.Op == PtAdd {
//		if ast.Left.InAcc && !ast.Right.InAcc {
//			emit("", Mac.OpAdd, ast.Right.Name) // Add X to ACC
//			ast.InAcc = true                    // result in accumulator
//		} else if !ast.Left.InAcc && ast.Right.InAcc {
//			emit("", Mac.OpAdd, ast.Left.Name) // Add X to ACC - take advantage of commutative
//			ast.InAcc = true                   // result in accumulator
//		} else if !ast.Left.InAcc && !ast.Right.InAcc {
//			emit("", Mac.OpLoad, ast.Left.Name) // load Left
//			emit("", Mac.OpAdd, ast.Right.Name) // Add X to ACC
//			ast.InAcc = true                    // result in accumulator
//		} else {
//			fmt.Printf("Error: bad tree at:%s : %s\n", godebug.LF(), DumpTree(ast, 0)) // xyzzy - dump tree
//		}
//	} else if ast.Op == PtSub {
//	} else if ast.Op == PtMul {
//
//		// PtLoad    = TokType(112) // ParseTree	-- Load from Memory
//		// PtStore   = TokType(113) // ParseTree	-- Save to Memroy
//		// PtInput   = TokType(101) // ParseTree  -- Perform input on symbol
//		// PtOutput  = TokType(102) // ParseTree	-- Perform output on symbol
//		// PtNUM     = TokType(104) // ParseTree	-- Constant / Number
//		// PtID      = TokType(105) // ParseTree	-- Identifier
//
//	} else {
//	}
//}
//
//func TypeCheck1_Incr_Decr(ast *ParseTree, errList *[]string) {
//	if ast == nil {
//		return
//	}
//	if ast.Left != nil {
//		TypeCheck1_Incr_Decr(ast.Left, errList)
//	}
//	if ast.Right != nil {
//		TypeCheck1_Incr_Decr(ast.Right, errList)
//	}
//	if ast.Op == PtIncr || ast.Op == PtDecr {
//		if ast.Left.Op != PtID {
//			*errList = append(*errList, "Type error - Must have an LValue (ID) for increment/decrement operations")
//		}
//	}
//}
//
//func ReWrite3_Incr_Decr(ast **ParseTree) {
//	if *ast == nil {
//		return
//	}
//	if (*ast).Left != nil {
//		ReWrite3_Incr_Decr(&((*ast).Left))
//	}
//	if (*ast).Right != nil {
//		ReWrite3_Incr_Decr(&((*ast).Right))
//	}
//	if (*ast).Op == PtIncr {
//		(*ast).Op = PtAdd
//		(*ast).OpName = "PtAdd"
//		(*ast).InAcc = true
//		st, _ := LookupConst(1, (*ast).LineNo)
//		(*ast).Right = &ParseTree{
//			Op:     PtNUM,
//			OpName: "PtNUM",
//			LineNo: (*ast).LineNo,
//			Name:   "_1",
//			Value:  1,
//			St:     st,
//		}
//		// Store result also - so ++ is permanent (has side effect).
//		TmpTree := *ast
//		TmpName := (*ast).Left.St.Name
//		TmpSt := (*ast).Left.St
//		(*ast) = &ParseTree{
//			Op:     PtStore,
//			OpName: "PtStore",
//			LineNo: (*ast).LineNo,
//			Name:   TmpName,
//			St:     TmpSt,
//			Left:   TmpTree,
//			InAcc:  true,
//		}
//	} else if (*ast).Op == PtDecr {
//		// xyzzy - should have a Store also
//		(*ast).Op = PtSub
//		(*ast).OpName = "PtSub"
//		(*ast).InAcc = true
//		st, _ := LookupConst(1, (*ast).LineNo)
//		(*ast).Right = &ParseTree{
//			Op:     PtNUM,
//			OpName: "PtNUM",
//			LineNo: (*ast).LineNo,
//			Name:   "_1",
//			Value:  1,
//			St:     st,
//		}
//		// Store result also - so ++ is permanent (has side effect).
//		TmpTree := *ast
//		TmpName := (*ast).Left.St.Name
//		TmpSt := (*ast).Left.St
//		(*ast) = &ParseTree{
//			Op:     PtStore,
//			OpName: "PtStore",
//			LineNo: (*ast).LineNo,
//			Name:   TmpName,
//			St:     TmpSt,
//			Left:   TmpTree,
//			InAcc:  true,
//		}
//	}
//}
//
//func ReWrite1_Expr_op_Expr(ast *ParseTree) (rv *ParseTree) {
//	if ast == nil {
//		return nil
//	}
//	if ast.Left != nil {
//		ast.Left = ReWrite1_Expr_op_Expr(ast.Left)
//	}
//	if ast.Right != nil {
//		ast.Right = ReWrite1_Expr_op_Expr(ast.Right)
//	}
//	TmpName := AllocateTemp(ast.LineNo)
//	st, _ := LookupSymbol(TmpName)
//	if ast.Op == PtAdd && ast.Left.InAcc && ast.Right.InAcc {
//		tmpTree := ast.Right
//		ast.Right = &ParseTree{
//			Op:     PtID,
//			OpName: "PtID",
//			LineNo: ast.LineNo,
//			Name:   TmpName,
//			St:     st,
//			Left: &ParseTree{
//				Op:     PtStore,
//				OpName: "PtStore",
//				LineNo: ast.LineNo,
//				Name:   TmpName,
//				St:     st,
//				Left:   tmpTree,
//			},
//		}
//	}
//	return ast
//}
//
//func genCode(ast *ParseTree, ofp *os.File) (err error) {
//
//	// Pass 1 - Assign constants names
//	kk := 1
//
//	ResetTemp()
//	LookupConst(1, 0) // Create constants 1 and 0
//	LookupConst(0, 0)
//
//	gen_AssignConstants(ast, &kk)
//
//	// Tree Re-write : 1
//	// 		xyzzy - assign temporary variables _tmp1, etc. for Expr(op)Expr - Right gets saved in Temp.
//	// 		Becomes (_tmp=(Right)) -> Expr(Left-in-Reg)(op)_tmp
//	// 		Always save the "Right" tree to a Temp, Then OP Right.
//	// Tree Re-write : 2 - remove Unary Minus -> 0 - expr
//	// Tree Re-write : 3 - remove ++ and -- -> expr + 1, expr - 1
//	var errList []string
//	TypeCheck1_Incr_Decr(ast, &errList)
//	if len(errList) > 0 {
//		err = fmt.Errorf("Type Errors:\n%s\n", errList)
//		return
//	}
//	ReWrite3_Incr_Decr(&ast)
//
//	ast = ReWrite1_Expr_op_Expr(ast)
//
//	k2 := 4
//	gen_Inorder(ast, &k2)
//
//	GenSymbols(ofp)
//	return
//}
//
////ToBe! func GenerateCode(ast *SyntaxTree, out string) (err error) {
//func GenerateCode(ast *ParseTree, out string) (err error) {
//	ofp, e0 := filelib.Fopen(out, "w")
//	if e0 != nil {
//		err = fmt.Errorf("Unable to open output file [%s] error %s\n", out, e0)
//		return
//	}
//	err = genCode(ast, ofp)
//	ofp.Close()
//	return
//}
// still used in cg.go - to be depricated for SyntaxTree
//type ParseTree struct {
//	Op     TokType
//	OpName string `json:",omitempty"`
//	St     SymbolTableType
//	Name   string `json:",omitempty"`
//	Value  int
//	Left   *ParseTree `json:",omitempty"`
//	Right  *ParseTree `json:",omitempty"`
//	LineNo int
//	InAcc  bool
//	Source string `json:",omitempty"`
//}
//old//// Test ReWrite3_Incr_Decr(&a1)
//old//// Also tests: TypeCheck1_Incr_Decr(a1, &errList)
//old//func Test_TreeRewrite01(t *testing.T) {
//old//
//old//	Tests := []struct {
//old//		Run         bool
//old//		Comment     string
//old//		Pos         int
//old//		Fn          string
//old//		ErrExpected bool
//old//		Ref         string
//old//	}{
//old//		{ /* 0 */
//old//			Run:         false,
//old//			Comment:     `Test of increment.  Needs to check that the incremented value is a LValue in expression.  Note: All PtID's are LValues!  Value needs to be modified and saved.`,
//old//			Fn:          "./test/scan_005.txt",
//old//			Pos:         1,
//old//			ErrExpected: false,
//old//			Ref:         "./ref/rr0_000.json",
//old//		},
//old//	}
//old//
//old//	for nn, test := range Tests {
//old//		if !test.Run {
//old//			fmt.Printf("Test skipped - run is false %d, at:%s\n", nn, godebug.LF())
//old//			continue
//old//		}
//old//		tk, _, err := Scanner(test.Fn)
//old//		if err != nil {
//old//			if !test.ErrExpected {
//old//				t.Errorf("[%d] Error not expected, got one:%s ", nn, err)
//old//			}
//old//			continue
//old//		}
//old//
//old//		if db0a {
//old//			fmt.Printf("%s\n", godebug.SVarI(tk))
//old//		}
//old//
//old//		// Build the AST array - so we can look at rewrite
//old//		pd := ParseData{
//old//			FileName: test.Fn,
//old//			LineNo:   1,
//old//			curPos:   0, // Start at beginning
//old//			tokens:   tk,
//old//			errList:  []string{},
//old//		}
//old//		astList := make([]*ParseTree, 0, 10)
//old//		for {
//old//			// 	cmp.go: 584: func ParseInput(pd *ParseData) (pt *ParseTree, err error) {
//old//			ast, err := ParseInput(&pd)
//old//			if ast == nil {
//old//				break
//old//			}
//old//
//old//			if err != nil {
//old//				// xyzzy - handle better
//old//				t.Errorf("[%d] Error on parse\n", nn)
//old//				// continue // xyzzy - handle better
//old//			}
//old//			if len(pd.errList) > 0 {
//old//				fmt.Printf("error list = %s\n", pd.errList)
//old//			}
//old//
//old//			astList = append(astList, ast)
//old//
//old//			if db4 {
//old//				fmt.Printf("parse Before Rewrite (ast) = %s\n", godebug.SVarI(ast))
//old//			}
//old//
//old//		}
//old//
//old//		a1 := astList[test.Pos] // Pick out the corret tree to test on.
//old//		if db8 {
//old//			fmt.Printf("parse Before Rewrite (ast) = %s\n", godebug.SVarI(a1))
//old//		}
//old//		var errList []string
//old//		TypeCheck1_Incr_Decr(a1, &errList)
//old//		if len(errList) == 0 {
//old//			if test.ErrExpected == true {
//old//				t.Errorf("[%d] Expected Error - did not get one.", nn)
//old//			} else {
//old//				ReWrite3_Incr_Decr(&a1)
//old//				if db8 {
//old//					fmt.Printf("AST After Rewrite (ast) = %s\n", godebug.SVarI(a1))
//old//				}
//old//			}
//old//		} else {
//old//			if test.ErrExpected == true {
//old//			} else {
//old//				t.Errorf("[%d] (got type errors when not expected to have errors) Type Error:%s.", nn, errList)
//old//			}
//old//		}
//old//
//old//		have := godebug.SVarI(a1)
//old//		ioutil.WriteFile(fmt.Sprintf("./out/rr0_%03d.json", nn), []byte(have), 0644)
//old//
//old//		cmd0 := fmt.Sprintf("/Users/pschlump/bin/jd -q -c out/rr0_%03d.json ref/rr0_%03d.json", nn, nn)
//old//		cmdS := strings.Split(cmd0, " ")
//old//
//old//		out, err := exec.Command(cmdS[0], cmdS[1:]...).Output()
//old//		if err != nil {
//old//			t.Errorf("[%d] error on exec! err:%s.", nn, err)
//old//		}
//old//		if string(out) != "" {
//old//			t.Errorf("[%d] Failed ->%s<-\n", nn, out)
//old//			fmt.Fprintf(os.Stderr, "%s", out)
//old//		}
//old//	}
//old//
//old//}
//old//
//old//func Test_TemporaryGeneration01(t *testing.T) {
//old//	// func gen_AssignConstants(ast *ParseTree, kk *int) {
//old//}
//old//
//old//func Test_CodeGen_01_GenerateVariables(t *testing.T) {
//old//}
