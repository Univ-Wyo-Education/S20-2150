
//func ReWrite2_UMinus(ast *ParseTree) (rv *ParseTree) {
//	if ast == nil {
//		return nil
//	}
//	if ast.Left != nil {
//		ast.Left = ReWrite2_UMinus(ast.Left)
//	}
//	if ast.Right != nil {
//		ast.Right = ReWrite2_UMinus(ast.Right)
//	}
//	if ast.Op == PtU_Minus {
//		ast.Op = PtSub
//		ast.Right = ast.Left
//		st, _ := LookupConst(0, ast.LineNo)
//		ast.Left = &ParseTree{
//			Op:     PtNum,
//			OpName: "PtNum",
//			LineNo: ast.LineNo,
//			Name:   "_0",
//			Value:  0,
//			St:     st,
//		}
//	}
//	return ast
//}

// ------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------

var nc = 0

// The parser calls this method to get each new token. This
// implementation returns operators and NUM.
func (x *exprLex) Lex(yylval *exprSymType) int {
	ct := x.Tokens[x.Pd.curPos]
	fmt.Printf("%s in .Lex - curPos=%d getting token %7d ->%s<->%s<-, at:%s \n%s", MiscLib.ColorYellow, x.Pd.curPos, ct.Tok, ct.SM, ct.TokName, godebug.LF(), MiscLib.ColorReset)
	x.Pd.curPos++
	nc++
	if nc > 15 {
		os.Exit(1)
	}
	if ct.Tok == TokNum {
		// yylval.tree = NewAst(OpNum, nil, nil, ct.LineNo)
		// yylval.tree.SValue = ct.SM
		// yylval.tree.IValue = ct.Value
		yylval.tree = NewAstNUM(ct.SM, ct.Value, ct.LineNo)
	}
	if ct.Tok == TokID {
		// yylval.tree = NewAst(OpID, nil, nil, ct.LineNo)
		// yylval.tree.SValue = ct.SM
		yylval.tree = NewAstID(ct.SM, ct.LineNo)
	}
	x.peek = rune(x.Tokens[x.Pd.curPos].Tok)
	return int(ct.Tok)

	//	for {
	//		c := x.next()
	//		switch c {
	//		case eof:
	//			return eof
	//		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
	//			return x.num(c, yylval)
	//		case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j':
	//			return x.id(c, yylval)
	//		case '+', '-', '*', '/', '(', ')', ';', '=':
	//			return int(c)

	//		// Recognize Unicode multiplication and division
	//		// symbols, returning what the parser expects.
	//		case 'ร':
	//			return '*'
	//		case 'รท':
	//			return '/'

	//		case ' ', '\t', '\r':
	//		case '\n':
	//			line_no++

	//		default:
	//			log.Printf("unrecognized character %q", c)
	//		}
	//	}
}

//// Lex a number.
//func (x *exprLex) num(c rune, yylval *exprSymType) int {
//	add := func(b *bytes.Buffer, c rune) {
//		if _, err := b.WriteRune(c); err != nil {
//			log.Fatalf("WriteRune: %s", err)
//		}
//	}
//	var b bytes.Buffer
//	add(&b, c)
//L:
//	for {
//		c = x.next()
//		switch c {
//		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E':
//			add(&b, c)
//		default:
//			break L
//		}
//	}
//	if c != eof {
//		x.peek = c
//	}
//	yylval.tree = NewAst(OpNum, nil, nil, x.Pd.LineNo)
//	yylval.tree.SValue = b.String()
//	// xyzzy - convert to int for other things
//
//	//	yylval.num = &big.Rat{}
//	//	_, ok := yylval.num.SetString(b.String())
//	//	if !ok {
//	//		log.Printf("bad number %q", b.String())
//	//		return eof
//	//	}
//
//	return NUM
//}
//
//// Lex an ID
//func (x *exprLex) id(c rune, yylval *exprSymType) int {
//	add := func(b *bytes.Buffer, c rune) {
//		if _, err := b.WriteRune(c); err != nil {
//			log.Fatalf("WriteRune: %s", err)
//		}
//	}
//	var b bytes.Buffer
//	add(&b, c)
//	yylval.tree = NewAst(OpID, nil, nil, x.Pd.LineNo)
//	yylval.tree.SValue = b.String()
//	return ID
//}
//
//// Return the next rune for the lexer.
//func (x *exprLex) next() rune {
//	if x.peek != eof {
//		r := x.peek
//		x.peek = eof
//		return r
//	}
//	if len(x.line) == 0 {
//		return eof
//	}
//	c, size := utf8.DecodeRune(x.line)
//	x.line = x.line[size:]
//	if c == utf8.RuneError && size == 1 {
//		log.Print("invalid utf8")
//		return x.next()
//	}
//	return c
//}

// The parser calls this method on a parse error.
func (x *exprLex) Error(s string) {
	log.Printf("parse error: %s", s)
}
