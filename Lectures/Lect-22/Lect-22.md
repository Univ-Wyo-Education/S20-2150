# System Software - Assemblers / Compilers / Linkers

## Videos

[https://youtu.be/lp4ib9WoqjU - Lect-22-2150-pt1.mp4](https://youtu.be/lp4ib9WoqjU)<br>
[https://youtu.be/ea6ibgXmJBA - Lect-22-2150-pt2.mp4](https://youtu.be/ea6ibgXmJBA)<br>
[https://youtu.be/3taUHQnKqjQ - Lect-22-2150-pt3.mp4](https://youtu.be/3taUHQnKqjQ)<br>

From Amazon S3 - for download (same as youtube videos)

[http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt1.mp4](http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt1.mp4)<br>
[http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt2.mp4](http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt2.mp4)<br>
[http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt3.mp4](http://uw-s20-2015.s3.amazonaws.com/Lect-22-2150-pt3.mp4)<br>

There will be a pt4 and others for Friday's Lecture out later today.

## Overview

One of the big developments in systems software (Chapter 8) was the development of
high level languages.  Please read Chapter 8 in the book.

The basic idea of system software is to build something that is farther away from
the machine and easier for humans to understand and use.

Research in this is ongoing with companies like IOHK developing domain specific
languages for FinTeck (Financial Technology).   If this kind of a thing interests
somebody -then- it makes a decent masters project to develop a DSL for things like
the insurance industry.

## How do Assemblers work.

Most assemblers are 2 pass systems.

Pass 1: Read the source and figure out where all the symbols are located.  In this
pass you pretend to do the assembly - but all you are looking for is the address of
all the symbols.

```
	Load X
	Store Y
	Halt
X,	Dec 10
Y,	Dec 0
```

Start at pc = 0

So you fake generate a Load instruction, increment pc to 1.

Fake generate Store, increment PC to 2.

Fake Generate Halt, increment PC to 3.

Read Label X - store this as having an address of 3.   Fake Dec 10, increment PC to 3.

Read Label Y - store this as having an address of 4.  Fake Dec 0, increment PC to 4.

Find the end of file - so done with pass 1.

Star at top - keeping the symbol table with X, address 3, Y Address 4.

Generate Load X - with a load instruction of 0x1000 and the address of X - we know that
now to be 3. So 0x1003.

Generate the Store Y - with a store instruction of 0x2000 and the address of Y - we know
that now to be 4. So 0x2004.

Generate the Halt, 0x7000.

Generate the Dec 10, 0x000a.

Generate the Dec 0, 0x0000.

Done.

## How do compilers work.

Compilers took a lot longer to build.  They have lots of fun parts.  The original compiler, Fortran
was originally build on circuit boards where the boards had to be put directly into the system.
The 1's and 0's were generated by cutting diodes out of the board.   I bet the developers got
blisters using wire cutters.

Fortran is still around - and still used - but it has "evolved" and is a much more useful language.
I learned Fortran in college - and still occasionally program in it.  Specifically I made fixes
to some genetic analysis code last week for looking at the evolution/mutation rate in COVID-19.

The big developments in compilers involved parsing of languages into trees and the formal specification
of languages.  Compilers today are super-reliable.  In 1989 when you had a defect in your code the
question was always is the compiler failing or is my code failing.  Also compilers tend to produce
really nice error messages today.   I used a Fortran-66 compiler that if you had a syntax error
it produced the message "syntax error." - but did not even tell you the line number that the error
was on.

So ...

How do copiers work. -- The 1990's easy view -- Later we will look at how a modern compiler works.

1. Symbol Table - Symbols are not just address - they have type and size information with them.
2. Scanner - This takes the input and coverts it into "tokens" so an "id" is a single thing to the next phase.
3. Parser - This converts the scanned tokens into a tree representation of the code.  This is often called an Abstract Syntax Tree (AST).
4. Code Generator - This takes the AST and generates code for it in assembly Language
5. Optimizer - This takes the code and re-writes it to be better code.
6. Assemble the output into a binary.
7. Link multiple binaries together into a final program.

## Interpreters.

Interpreted languages like "java" and "python" were built to run the AST directly - at least in the original form of the language.
Later this AST was translated into a P-CODE - an assembly for a virtual machine that did not exist.   This made the execution
faster.  Then things like optimizes could work on the code.  Also porting to new machines just meant re-writing the emulator.
Then they started Just-In-Time compiling the code to make them faster.  This meant doing the final step of the compile - to
translate the P-Code into machine code - as the program ran.   This made them faster.

More modern languages like Go and Rust have avoided this - by doing all the work up front.

The most common data storage and analysis systems are interpreters.  Microsoft Excel for example.






# Copyright

Copyright (C) University of Wyoming, 2020.

